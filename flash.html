<!-- ...existing code... -->
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Flashcards Minka SDG</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }

    #app {
      max-width: 800px;
      margin: 0 auto;
    }

    /* fixed container to avoid jumps between portrait/landscape */
    .image-container {
      width: 100%;
      max-width: 900px;
      height: 60vh; /* fixed height so cards don't jump */
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fafafa;
      border-radius: 8px;
      overflow: hidden;
      margin: 0 auto 8px auto;
    }

    img.card-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      transition: opacity .2s ease;
      opacity: 0;
    }

    img.card-image.loaded {
      opacity: 1;
    }

    /* small tweaks for orientation if needed (does not change container size) */
    img.card-image.portrait {
      padding: 8px 20px;
    }
    img.card-image.landscape {
      padding: 8px 4px;
    }

    @media (max-width: 768px) {
      .image-container { height: 55vh; }
    }

    .attribution {
      font-size: 0.9em;
      color: #555;
      margin-bottom: 12px;
    }

    .card {
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    button {
      margin: 8px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 6px;
      border: none;
      background: #007bff;
      color: white;
    }

    button:hover {
      background: #0056b3;
    }

    .export-import {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1 id="page-title">Flashcards Minka SDG</h1>
    <div id="screen"></div>
  </div>

  <script>
    const API_PATH = "https://api.minka-sdg.org/v1";
    let deck = [];
    let currentIndex = 0;
    let failedCards = [];
    let language = "es";
    let cardLimit = 25;
    let answered = false;

    // Translations
    const MSG = {
      en: {
        title: "Minka SDG Flashcards",
        languageLabel: "Language:",
        quantityLabel: "Number of cards:",
        startButton: "Start",
        importButton: "Import failed",
        importFileAria: "Select JSON file with failed cards",
        loading: "Loading {n} cards...",
        showAnswer: "Show answer",
        known: "I knew it",
        failed: "I didn't!",
        summaryTitle: "Summary",
        summaryText: "You failed {n} species:",
        exportButton: "Export failed",
        backButton: "Back to start",
        noImage: "No image"
      },
      es: {
        title: "Flashcards Minka SDG",
        languageLabel: "Idioma:",
        quantityLabel: "Cantidad de tarjetas:",
        startButton: "Iniciar",
        importButton: "Importar falladas",
        importFileAria: "Selecciona un archivo JSON con tarjetas falladas",
        loading: "Cargando {n} tarjetas...",
        showAnswer: "Muestra respuesta",
        known: "Lo sabía",
        failed: "¡No lo sabía!",
        summaryTitle: "Resumen",
        summaryText: "Fallaste {n} especies:",
        exportButton: "Exportar falladas",
        backButton: "Volver al inicio",
        noImage: "Sin imagen"
      },
      ca: {
        title: "Flashcards Minka SDG",
        languageLabel: "Idioma:",
        quantityLabel: "Nombre de targetes:",
        startButton: "Iniciar",
        importButton: "Importa fallades",
        importFileAria: "Selecciona un fitxer JSON amb targetes fallades",
        loading: "Carregant {n} targetes...",
        showAnswer: "Mostra resposta",
        known: "Ho sabia",
        failed: "No ho sabia!",
        summaryTitle: "Resum",
        summaryText: "Has fallat {n} espècies:",
        exportButton: "Exporta fallades",
        backButton: "Tornem a l'inici",
        noImage: "Sense imatge"
      }
    };

    function t(key, vars = {}) {
      const s = (MSG[language] && MSG[language][key]) || MSG['en'][key] || key;
      return s.replace(/\{(\w+)\}/g, (_, k) => vars[k] ?? "");
    }
let firstVisit = true; // 👈 nueva variable global

function showStartScreen() {
  document.getElementById("page-title").textContent = t('title');

  let introText = "";
  if (firstVisit) {
    introText = `
      <p style="text-align:justify; max-width:700px; margin:0 auto 1em auto;">
        La aplicación de tarjetas de memoria (flashcards) utiliza la técnica de la repetición espaciada y autoevaluación para mejorar la retención de información a largo plazo. 
        Al estudiar, el usuario responde mentalmente a la pregunta de la tarjeta y luego revela la respuesta; debe autoevaluarse seleccionando si acertó o no la respuesta, 
        lo que determina si volverá a repasar esa tarjeta.
      </p>
      <p style="text-align:justify; max-width:700px; margin:0 auto 1em auto;">
        L'aplicació de targetes de memòria (flashcards) utilitza la tècnica de la repetició espaiada i l'autoevaluació per millorar la retenció d'informació a llarg termini. 
        Quan estudia, l'usuari respon mentalment a la pregunta de la targeta i després revela la resposta; ha d'autoavaluar-se seleccionant si ha encertat o no la resposta, 
        cosa que determina si tornarà a repassar aquesta targeta.
      </p>
      <p style="text-align:justify; max-width:700px; margin:0 auto 2em auto;">
        The flashcard application uses the technique of spaced repetition and self-evaluation to improve long-term information retention. 
        While studying, the user mentally answers the flashcard's question and then reveals the answer; they must self-assess by selecting whether they got the answer right or not, 
        which determines if they will review that flashcard again.
      </p>
    `;
    firstVisit = false; // 👈 aseguramos que no se vuelva a mostrar
  }

  document.getElementById("screen").innerHTML = `
    <div>
      ${introText}
      <label>${t('languageLabel')}
        <select id="lang">
          <option value="es">Español</option>
          <option value="ca">Català</option>
          <option value="en">English</option>
        </select>
      </label>
      <br><br>
      <label>${t('quantityLabel')}
        <select id="limit">
          <option value="25">25</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
      </label>
      <br><br>
      <button id="start-btn">${t('startButton')}</button>
      <div class="export-import">
        <button id="import-btn">${t('importButton')}</button>
        <input type="file" id="importFile" style="display:none" aria-label="${t('importFileAria')}" />
      </div>
    </div>
  `;

  document.getElementById("lang").value = language;
  document.getElementById("limit").value = cardLimit;

  document.getElementById("start-btn").onclick = startDeck;
  document.getElementById("import-btn").onclick = importDeck;
}
    async function startDeck() {
      language = document.getElementById("lang").value;
      cardLimit = parseInt(document.getElementById("limit").value, 10);

      // show loading with chosen number
      document.getElementById("page-title").textContent = t('title');
      document.getElementById("screen").innerHTML = `<p>${t('loading', {n: cardLimit})}</p>`;

      // Collect all observations for the project (paginated)
      const projectId = 184; // keep project id here; change if needed
      let allObservations = [];
      let page = 1;
      try {
        while (true) {
          const res = await fetch(`${API_PATH}/observations?project_id=${projectId}&per_page=200&page=${page}`);
          const json = await res.json();
          if (!Array.isArray(json.results) || json.results.length === 0) break;
          allObservations = allObservations.concat(json.results);
          // if total results less than requested per_page, we can break early when pages exhausted
          if (!json.next) break; // if API provides pagination link
          page++;
          // safety: prevent infinite loop
          if (page > 200) break;
        }
      } catch (e) {
        console.error("Error fetching observations:", e);
      }

      if (allObservations.length === 0) {
        document.getElementById("screen").innerHTML = `<p>No observations found.</p><button onclick="showStartScreen()">${t('backButton')}</button>`;
        return;
      }

      // shuffle and pick requested number
      shuffleArray(allObservations);
      const chosen = allObservations.slice(0, Math.min(cardLimit, allObservations.length));

      // load full card objects
      deck = await Promise.all(chosen.map(loadCard));
      currentIndex = 0;
      failedCards = [];
      showCard();
    }

    async function loadCard(obs) {
      // Ensure we have photos array
      const photos = (obs.photos || []).map(p => (p.url || "").replace("/square.", "/original."));
      const attributions = (obs.photos || []).map(p => p.attribution || "");
      const taxon = obs.taxon || {};
      let commonName = "";
      try {
        if (taxon.id) {
          const res = await fetch(`${API_PATH}/taxa?taxon_id=${taxon.id}&locale=${language}`);
          const json = await res.json();
          commonName = json.results?.[0]?.preferred_common_name || "";
        }
      } catch (e) {
        commonName = "";
      }
      return {
        id: obs.id,
        photos: photos.length ? photos : [null],
        attributions,
        scientific: taxon.name || "N/A",
        common: commonName
      };
    }

    function showCard() {
      if (deck.length === 0) {
        showSummary();
        return;
      }
      answered = false;
      const card = deck[currentIndex];
      const imgSrc = card.photos[0];
      const attribution = card.attributions[0] || "";
      document.getElementById("screen").innerHTML = `
        <div class="card">
          <div class="image-container">
            ${imgSrc ? `<img id="card-img" src="${imgSrc}" class="card-image" alt="card image"/>` : `<div style="color:#777">${t('noImage')}</div>`}
          </div>
          <div class="attribution">${escapeHtml(attribution)}</div>
          <div id="answer" style="margin: 15px; font-size: 1.2em;">???</div>
          <button id="show-answer-btn">${t('showAnswer')}</button>
        </div>
      `;

      const img = document.getElementById('card-img');
      if (img) {
        img.onload = () => {
          // determine orientation and add class
          try {
            const isPortrait = img.naturalHeight > img.naturalWidth;
            img.classList.add(isPortrait ? 'portrait' : 'landscape', 'loaded');
          } catch (e) {
            img.classList.add('loaded');
          }
        };
        img.onerror = () => {
          img.remove();
          const container = document.querySelector('.image-container');
          if (container) container.innerHTML = `<div style="color:#777">${t('noImage')}</div>`;
        };
      }

      document.getElementById('show-answer-btn').onclick = showAnswer;
    }

    function showAnswer() {
      const card = deck[currentIndex];
      document.getElementById("answer").innerHTML = `
        🌱 <strong>${language.toUpperCase()}:</strong> ${escapeHtml(card.common || "N/A")}<br>
        🌿 <strong>Scientific:</strong> ${escapeHtml(card.scientific)}
      `;
      if (!answered) {
        const screen = document.getElementById("screen");
        screen.innerHTML += `
          <button id="known-btn">${t('known')}</button>
          <button id="failed-btn">${t('failed')}</button>
        `;
        document.getElementById('known-btn').onclick = markKnown;
        document.getElementById('failed-btn').onclick = markFailed;
        answered = true;
      }
    }

    function markKnown() {
      deck.splice(currentIndex, 1);
      if (currentIndex >= deck.length) currentIndex = 0;
      showCard();
    }

    function markFailed() {
      // push failed card to failed list and move it to end of deck
      failedCards.push(deck[currentIndex]);
      deck.push(deck[currentIndex]);
      deck.splice(currentIndex, 1);
      if (currentIndex >= deck.length) currentIndex = 0;
      showCard();
    }

    function showSummary() {
      const list = failedCards.map(c => `<li>${escapeHtml(c.scientific)} (${escapeHtml(c.common || "N/A")})</li>`).join("");
      document.getElementById("screen").innerHTML = `
        <h2>${t('summaryTitle')}</h2>
        <p>${t('summaryText', {n: failedCards.length})}</p>
        <ul>${list}</ul>
        <button id="export-btn">${t('exportButton')}</button>
        <button id="back-btn">${t('backButton')}</button>
      `;
      document.getElementById('export-btn').onclick = exportDeck;
      document.getElementById('back-btn').onclick = showStartScreen;
    }

    function exportDeck() {
      const blob = new Blob([JSON.stringify(failedCards, null, 2)], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "failed_cards.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function importDeck() {
      const fileInput = document.getElementById("importFile");
      fileInput.click();
      fileInput.onchange = async () => {
        try {
          const file = fileInput.files[0];
          const text = await file.text();
          const parsed = JSON.parse(text);
          if (!Array.isArray(parsed)) throw new Error("Invalid format");
          failedCards = parsed;
          deck = [...failedCards];
          currentIndex = 0;
          showCard();
        } catch (e) {
          alert("Import failed: " + (e.message || e));
        } finally {
          fileInput.value = "";
        }
      };
    }

    // utility: shuffle in-place
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // simple escape to avoid injecting HTML from API attributions
    function escapeHtml(s) {
      if (!s) return "";
      return s.replace(/[&<>"']/g, function (m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
      });
    }

    // start
    showStartScreen();
  </script>
</body>
</html>
